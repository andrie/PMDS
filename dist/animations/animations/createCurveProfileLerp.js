import{c as z,v as A,L as d,a5 as I,o as g,a6 as V}from"./makeScene2D.js";function X(){const n=new Map;return n.entries(),new Proxy(n,B)}const B={get(n,t){if(Reflect.has(n,t))return Reflect.get(n,t);if(t==="mapRefs")return function(e){const o=[];for(const s of n.values())o.push(e(s(),o.length));return o};if(typeof t=="string"){let e=n.get(t);return e||(e=z(),n.set(t,e)),e}},has(n,t){return Reflect.has(n,t)?!0:typeof t=="string"?n.has(t):!1}};function E(n,t,e){const o={arcLength:0,segments:[],minSin:1};if(n.length===0)return o;if(e){const i=n[0].add(n[n.length-1]).scale(.5);n=[i,...n,i]}let s=n[0];for(let i=2;i<n.length;i++){const r=n[i-2],l=n[i-1],a=n[i],M=r.sub(l),w=a.sub(l),u=M.normalized.safe,f=w.normalized.safe,y=Math.acos(A(-1,1,u.dot(f))),h=Math.tan(y/2),m=Math.sin(y/2),p=Math.min(t,h*M.magnitude*(i===2?1:.5),h*w.magnitude*(i===n.length-1?1:.5)),x=m===0?0:p/m,v=h===0?0:p/h,O=u.add(f).scale(1/2).normalized.safe.scale(x).add(l),P=u.perpendicular.dot(f)<0,b=new d(s,l.add(u.scale(v))),L=new I(O,p,u.perpendicular.scale(P?1:-1),f.perpendicular.scale(P?-1:1),P);b.arcLength>0&&(o.segments.push(b),o.arcLength+=b.arcLength),L.arcLength>0&&(o.segments.push(L),o.arcLength+=L.arcLength),o.minSin=Math.min(o.minSin,Math.abs(m)),s=l.add(f.scale(v))}const c=new d(s,n[n.length-1]);return c.arcLength>0&&(o.segments.push(c),o.arcLength+=c.arcLength),o}function H(n,t){for(let e=0;e<n.length-1;e++){const o=n[e];let s=n[e+1];for(;o.sub(s).magnitude>t;)s=g.lerp(o,s,.5),n.splice(e+1,0,s)}}function j(n,t){const e=[];let o=null;for(const s of n.segments){if(!(s instanceof d))return null;e.push(s.from),o=s.to}return o&&e.push(o),!Number.isNaN(t)&&t>0&&H(e,t),e}function k(n){return n.reduce((t,e,o)=>{const s=n[(o+1)%n.length];return t+(e.y*s.x-e.x*s.y)},0)/2}function F(n,t){const e=[];let o=3;!Number.isNaN(t)&&t>0&&(o=Math.max(o,Math.ceil(n.arcLength/t)));for(let s=0;s<o;s+=1){const c=V(n,n.arcLength*(s/(o-1)));e.push(c.position)}return k(e)>0&&e.reverse(),e}function D(n){if(n.segments.length===0)return[];let t={arcLength:0,minSin:0,segments:[],closed:!1},e=null;const o=[t];for(const s of n.segments){const c=s.getPoint(0).position;e&&!c.equals(e)&&(t={arcLength:0,minSin:0,segments:[],closed:!1},o.push(t)),t.segments.push(s),t.arcLength+=s.arcLength,e=s.getPoint(1).position}for(const s of o)s.closed=s.segments[0].getPoint(0).position.equals(s.segments[s.segments.length-1].getPoint(1).position);return o}function R(n,t){return{points:[...j(n,t)||F(n,t)],closed:n.closed}}function G(n){return n.reduce((t,e,o)=>o?t+n[o-1].sub(e).magnitude:0,0)}function N(n,t){const e=n.length+t,o=G(n)/t;let s=0,c=0,i=o/2;for(;n.length<e;){const r=n[s],l=n[(s+1)%n.length],a=r.sub(l).magnitude;i<=c+a?(n.splice(s+1,0,a?g.lerp(r,l,(i-c)/a):new g(r)),i+=o):(c+=a,s+=1)}}function S(n,t,e){const o=n.length;let s=0;for(let c=0;c<t.length;c+=1){const i=n[(e+c)%o],r=t[c];s+=i.sub(r).squaredMagnitude}return s}function C(n,t){const{points:e,closed:o}=n,s=e.length;if(o){let c=1/0,i=0;const r=e.pop();for(let l=0;l<s;l+=1){const a=S(e,t.points,l);a<c&&(c=a,i=l)}if(r&&e.push(r),i){e.pop();const l=e.splice(0,i);e.splice(e.length,0,...l),e.push(e[0])}}else{const c=S(e,t.points,0),i=[...e].reverse();S(i,t.points,0)<c&&(n.points=i)}}function T({points:n,...t},e){const o=e>=1?10**e:1;return{points:n.map(s=>{const[c,i]=[s.x,s.y].map(r=>Math.round(r*o)/o);return new g(c,i)}),...t}}function J(n,t,e,o){const s=e,c=R(n,s),i=R(t,s),r=c.points.length-i.points.length;return N(c.points,r<0?r*-1:0),N(i.points,r>0?r:0),!n.closed&&t.closed?C(i,c):C(c,i),{from:T(c,o),to:T(i,o)}}function q(n,t){for(let e=n.length;e<t.length;e++){const o=t[e].segments[0].getPoint(0).position;n.push({arcLength:0,closed:!1,minSin:0,segments:[new d(o,o)]})}}function K(n,t,e,o){const s=D(n),c=D(t);return s.length<c.length?q(s,c):q(c,s),s.map((i,r)=>J(i,c[r],e,o))}function Q(n,t){const{segments:e,arcLength:o,minSin:s}=t;n.segments.push(...e),n.arcLength+=o,n.minSin=Math.min(n.minSin,s)}function U(n,t,e){const o=[];if(e===0)return[...n];if(e===1)return[...t];for(let s=0;s<n.length;s++){const c=n[s],i=t[s];o.push(g.lerp(c,i,e))}return o}function Y(n,t){const e=K(n,t,5,4);return o=>{const s={segments:[],arcLength:0,minSin:1};for(const{from:c,to:i}of e){const r=U(c.points,i.points,o);Q(s,E(r,0,!1))}return s}}export{X as a,S as b,Y as c,U as d,E as g,G as p};
